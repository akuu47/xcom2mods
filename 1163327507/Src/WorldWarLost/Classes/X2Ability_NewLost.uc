class X2Ability_NewLost extends X2Ability config(WWLData) dependson(XComGameStateContext_Ability);

var config int LOST_HOWLER_SOUND_MAGNITUDE;
var config int LOSTHOWLER_LOCAL_COOLDOWN;
var config int LOSTHOWLER_GLOBAL_COOLDOWN;
var config float LOST_BURNING_DMG_MULTIPLIER;
var config array<name> LOST_EXCLUDE_TYPES;

static function array<X2DataTemplate> CreateTemplates()
{
	local array<X2DataTemplate> Templates;

	Templates.AddItem(CreateLostAttack());
	Templates.AddItem(CreateLostHowl());
	Templates.AddItem(CreateBrutePoison());
	

	return Templates;
}

static function X2DataTemplate CreateLostHowl()
{
	local X2AbilityTemplate Template;
	local X2AbilityCost_ActionPoints ActionPointCost;
	local X2AbilityCooldown_LocalAndGlobal Cooldown;
	local X2AbilityCharges Charges;
	local X2AbilityCost_Charges ChargeCost;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'LostHowl');
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_beserk";
	Template.Hostility = eHostility_Neutral;
	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = false;
	Template.AbilityCosts.AddItem(ActionPointCost);

	// Update - one time use ability.
	Charges = new class 'X2AbilityCharges';
	Charges.InitialCharges = 1;
	Template.AbilityCharges = Charges;

	ChargeCost = new class'X2AbilityCost_Charges';
	ChargeCost.NumCharges = 1;
	Template.AbilityCosts.AddItem(ChargeCost);

	Cooldown = new class'X2AbilityCooldown_LocalAndGlobal';
	Cooldown.iNumTurns = default.LOSTHOWLER_LOCAL_COOLDOWN;
	Cooldown.NumGlobalTurns = default.LOSTHOWLER_GLOBAL_COOLDOWN;
	Template.AbilityCooldown = Cooldown;
	
	Template.LostSpawnIncreasePerUse = default.LOST_HOWLER_SOUND_MAGNITUDE;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	
//BEGIN AUTOGENERATED CODE: Template Overrides 'LostHowlerAbility'
	Template.bShowActivation = true;
	Template.CustomFireAnim = 'NO_Howl';
	Template.CinescriptCameraType = "Lost_Howel";
//END AUTOGENERATED CODE: Template Overrides 'LostHowlerAbility'
	
	return Template;
}



static function X2DataTemplate CreateLostAttack()
{

    local X2AbilityTemplate                 Template;
	local X2AbilityCost_ActionPoints        ActionPointCost;
	//local X2AbilityToHitCalc_StandardMelee  StandardMelee;
	local X2Effect_ApplyWeaponDamage PhysicalDamageEffect;
	local X2Condition_UnitProperty TargetPropertyCondition;
	local X2Effect_SpawnLostZombie SpawnLostZombieEffect;
	local X2Condition_UnitValue UnitValue;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'LostAttack');

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.MergeVisualizationFn = LostAttack_MergeVisualization;
	Template.BuildInterruptGameStateFn = TypicalAbility_BuildInterruptGameState;
	Template.CustomFireAnim = 'FF_Melee';

	Template.CinescriptCameraType = "Lost_Attack";
//BEGIN AUTOGENERATED CODE: Template Overrides 'LostAttack'
	Template.bFrameEvenWhenUnitIsHidden = true;
//END AUTOGENERATED CODE: Template Overrides 'LostAttack'

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityToHitCalc = new class'X2AbilityToHitCalc_StandardMelee';
	Template.AbilityTargetStyle = default.SimpleSingleMeleeTarget;

	// Shooter Conditions
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);

	// Target Conditions
	Template.AbilityTargetConditions.AddItem(default.LivingHostileTargetProperty);
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	//Template.AddShooterEffectExclusions();

	// Damage Effect
	PhysicalDamageEffect = new class'X2Effect_ApplyWeaponDamage';
	Template.AddTargetEffect(PhysicalDamageEffect);

	// DO NOT CHANGE THE ORDER OF THE DAMAGE AND THIS EFFECT
	// Apply this effect to the target if it died
	SpawnLostZombieEffect = new class'X2Effect_SpawnLostZombie';
	SpawnLostZombieEffect.BuildPersistentEffect(1);
	SpawnLostZombieEffect.DamageTypes.AddItem('melee');

	// The unit must be organic, dead, and not an alien
	TargetPropertyCondition = new class'X2Condition_UnitProperty';
	TargetPropertyCondition.ExcludeDead = false;
	TargetPropertyCondition.ExcludeAlive = true;
	TargetPropertyCondition.ExcludeRobotic = true;
	TargetPropertyCondition.ExcludeOrganic = false;
	TargetPropertyCondition.ExcludeAlien = true;
	TargetPropertyCondition.ExcludeCivilian = false;
	TargetPropertyCondition.ExcludeCosmetic = true;
	TargetPropertyCondition.ExcludeFriendlyToSource = true;
	TargetPropertyCondition.ExcludeHostileToSource = false;
	TargetPropertyCondition.FailOnNonUnits = true;
	SpawnLostZombieEffect.TargetConditions.AddItem(TargetPropertyCondition);

	// This effect is only valid if the target has not yet been turned into a zombie
	UnitValue = new class'X2Condition_UnitValue';
	UnitValue.AddCheckValue(class'X2Effect_SpawnLostZombie'.default.TurnedZombieName, 1, eCheck_LessThan);
	SpawnLostZombieEffect.TargetConditions.AddItem(UnitValue);

	Template.AddTargetEffect(SpawnLostZombieEffect);
	// DO NOT CHANGE THE ORDER OF THE DAMAGE AND THIS EFFECT
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildInterruptGameStateFn = TypicalAbility_BuildInterruptGameState;
	Template.BuildVisualizationFn = LostZombie_BuildVisualization;

	return Template;
}

simulated function LostAttack_MergeVisualization(X2Action BuildTree, out X2Action VisualizationTree)
{
	local XComGameStateContext_Ability MyAbilityContext;
	local XComGameStateContext_Ability TestAbilityContext;
	local XComGameStateVisualizationMgr VisMgr;
	local X2Action_ExitCover MyExitCover;
	local X2Action_Fire MyFireAction;
	local Array<X2Action> TestActions;
	local X2Action_ExitCover DrivingExitCover;
	local X2Action_Fire DrivingFireAction;
	local int ActionIndex;
	local bool bMergedAlready;
	local XComGameState_Unit TargetGameState;
	local int DamageResultIndex;
	local X2Action_ApplyWeaponDamageToUnit DrivingApplyWeaponDamageToUnit;
	local X2Action TestMarkerAction;
	local X2Action_MarkerNamed CameraReplaceAction;

	VisMgr = `XCOMVISUALIZATIONMGR;

	MyAbilityContext = XComGameStateContext_Ability(BuildTree.StateChangeContext);
	if( MyAbilityContext.bSkipAdditionalVisualizationSteps )
	{
		// we only need one LookAt, so replace all the others with filler
		if( VisualizationTree != None )
		{
			VisMgr.GetNodesOfType(BuildTree, class'X2Action_CameraLookAt', TestActions);
			foreach TestActions(TestMarkerAction)
			{
				CameraReplaceAction = X2Action_MarkerNamed(class'X2Action_MarkerNamed'.static.CreateVisualizationAction(MyAbilityContext));
				CameraReplaceAction.SetName("LostAttackCameraLookAtReplacement");
				VisMgr.ReplaceNode(CameraReplaceAction, TestMarkerAction);
			}
		}

		MyExitCover = X2Action_ExitCover(VisMgr.GetNodeOfType(BuildTree, class'X2Action_ExitCover', , MyAbilityContext.InputContext.SourceObject.ObjectID));
		MyFireAction = X2Action_Fire(VisMgr.GetNodeOfType(BuildTree, class'X2Action_Fire', , MyAbilityContext.InputContext.SourceObject.ObjectID));
		
		// Jwats: Line up the Exit Covers
		VisMgr.GetNodesOfType(VisualizationTree, class'X2Action_ExitCover', TestActions);
		for( ActionIndex = 0; ActionIndex < TestActions.Length; ++ActionIndex )
		{
			TestAbilityContext = XComGameStateContext_Ability(TestActions[ActionIndex].StateChangeContext);
			if( TestAbilityContext != None && !TestAbilityContext.bSkipAdditionalVisualizationSteps )
			{
				DrivingExitCover = X2Action_ExitCover(TestActions[ActionIndex]);
				VisMgr.DisconnectAction(MyExitCover);
				VisMgr.ConnectAction(MyExitCover, VisualizationTree, false, None, TestActions[ActionIndex].ParentActions);
				bMergedAlready = true;
				break;
			}
		}

		// Jwats: Find the driving fire action
		VisMgr.GetNodesOfType(VisualizationTree, class'X2Action_Fire', TestActions);
		for( ActionIndex = 0; ActionIndex < TestActions.Length; ++ActionIndex )
		{
			TestAbilityContext = XComGameStateContext_Ability(TestActions[ActionIndex].StateChangeContext);
			if( TestAbilityContext != None && !TestAbilityContext.bSkipAdditionalVisualizationSteps )
			{
				DrivingFireAction = X2Action_Fire(TestActions[ActionIndex]);
				break;
			}
		}

		// Jwats: Now Make sure both fires wait for both exit covers
		TestActions.Length = 0;
		TestActions.AddItem(MyExitCover);
		TestActions.AddItem(DrivingExitCover);
		VisMgr.ConnectAction(MyFireAction, VisualizationTree, false, , TestActions);
		VisMgr.ConnectAction(DrivingFireAction, VisualizationTree, false, , TestActions);

		// bsg-blittrell: Find the driving "X2Action_ApplyWeaponDamageToUnit", and add our damage to it
		VisMgr.GetNodesOfType(VisualizationTree, class'X2Action_ApplyWeaponDamageToUnit', TestActions);
		TargetGameState = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(MyAbilityContext.InputContext.PrimaryTarget.ObjectID));
		for( ActionIndex = 0; ActionIndex < TestActions.Length; ++ActionIndex )
		{
			TestAbilityContext = XComGameStateContext_Ability(TestActions[ActionIndex].StateChangeContext);
			if( TestAbilityContext != None && !TestAbilityContext.bSkipAdditionalVisualizationSteps )
			{
				DrivingApplyWeaponDamageToUnit = X2Action_ApplyWeaponDamageToUnit(TestActions[ActionIndex]);				

				for(DamageResultIndex = 0; DamageResultIndex < TargetGameState.DamageResults.Length; ++DamageResultIndex)
				{
					if( TargetGameState.DamageResults[DamageResultIndex].Context != MyAbilityContext )
					{
						// wasn't damaged by this ability usage, so not the record we're looking for
						continue;
					}

					DrivingApplyWeaponDamageToUnit.HitResults.AddItem(MyAbilityContext.ResultContext.HitResult);
					DrivingApplyWeaponDamageToUnit.DamageResults.AddItem(TargetGameState.DamageResults[DamageResultIndex]);
				}
				break;
			}
		}
	}
	
	if ( !bMergedAlready )
	{
		MyAbilityContext.SuperMergeIntoVisualizationTree(BuildTree, VisualizationTree);
	}
}

simulated function LostZombie_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateHistory History;
	local XComGameStateContext_Ability Context;
	local StateObjectReference InteractingUnitRef;

	local VisualizationActionMetadata EmptyTrack;
	local VisualizationActionMetadata SourceTrack, ActionMetadata, ZombieTrack;
	local XComGameState_Unit SpawnedUnit, DeadUnit;
	local UnitValue SpawnedUnitValue;
	local X2Effect_SpawnLostZombie SpawnLostZombieEffect;
	local X2Action ExitCoverAction;
	local int j;
	local name SpawnLostZombieEffectResult;
	local X2VisualizerInterface TargetVisualizerInterface;

	History = `XCOMHISTORY;

	Context = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	InteractingUnitRef = Context.InputContext.SourceObject;

	//Configure the visualization track for the shooter
	//****************************************************************************************
	SourceTrack = EmptyTrack;
	SourceTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	SourceTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	SourceTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	ExitCoverAction = class'X2Action_ExitCover'.static.AddToVisualizationTree(SourceTrack, Context);

	if (Context.InterruptionStatus != eInterruptionStatus_None)
	{
		//Insert markers for the subsequent interrupt to insert into
		class'X2Action'.static.AddInterruptMarkerPair(SourceTrack, Context, ExitCoverAction);
	}

	class'X2Action_Fire'.static.AddToVisualizationTree(SourceTrack, Context);
	class'X2Action_EnterCover'.static.AddToVisualizationTree(SourceTrack, Context);

	// Configure the visualization track for the Lost zombie
	//******************************************************************************************
	InteractingUnitRef = Context.InputContext.PrimaryTarget;
	ActionMetadata = EmptyTrack;
	ActionMetadata.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	ActionMetadata.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	ActionMetadata.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	class'X2Action_WaitForAbilityEffect'.static.AddToVisualizationTree(ActionMetadata, Context, false, ActionMetadata.LastActionAdded);

	for( j = 0; j < Context.ResultContext.TargetEffectResults.Effects.Length; ++j )
	{
		SpawnLostZombieEffect = X2Effect_SpawnLostZombie(Context.ResultContext.TargetEffectResults.Effects[j]);
		SpawnLostZombieEffectResult = 'AA_UnknownError';

		if( SpawnLostZombieEffect != none )
		{
			SpawnLostZombieEffectResult = Context.ResultContext.TargetEffectResults.ApplyResults[j];
		}
		else
		{
			// Target effect visualization
			Context.ResultContext.TargetEffectResults.Effects[j].AddX2ActionsForVisualization(VisualizeGameState, ActionMetadata, Context.ResultContext.TargetEffectResults.ApplyResults[j]);

			// Source effect visualization
			Context.ResultContext.TargetEffectResults.Effects[j].AddX2ActionsForVisualizationSource(VisualizeGameState, SourceTrack, Context.ResultContext.TargetEffectResults.ApplyResults[j]);
		}
	}

	TargetVisualizerInterface = X2VisualizerInterface(ActionMetadata.VisualizeActor);
	if( TargetVisualizerInterface != none )
	{
		//Allow the visualizer to do any custom processing based on the new game state. For example, units will create a death action when they reach 0 HP.
		TargetVisualizerInterface.BuildAbilityEffectsVisualization(VisualizeGameState, ActionMetadata);
	}

	if( SpawnLostZombieEffectResult == 'AA_Success' )
	{
		DeadUnit = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID));
		`assert(DeadUnit != none);
		DeadUnit.GetUnitValue(class'X2Effect_SpawnUnit'.default.SpawnedUnitValueName, SpawnedUnitValue);

		ZombieTrack = EmptyTrack;
		ZombieTrack.StateObject_OldState = History.GetGameStateForObjectID(SpawnedUnitValue.fValue, eReturnType_Reference, VisualizeGameState.HistoryIndex);
		ZombieTrack.StateObject_NewState = ZombieTrack.StateObject_OldState;
		SpawnedUnit = XComGameState_Unit(ZombieTrack.StateObject_NewState);
		`assert(SpawnedUnit != none);
		ZombieTrack.VisualizeActor = History.GetVisualizer(SpawnedUnit.ObjectID);

		SpawnLostZombieEffect.AddSpawnVisualizationsToTracks(Context, SpawnedUnit, ZombieTrack, DeadUnit, ActionMetadata);
	}
}

static function X2AbilityTemplate CreateBrutePoison()
{
	local X2AbilityTemplate						Template;
	local X2Effect_ApplyWeaponDamage            DamageEffect;
	local X2AbilityMultiTarget_Radius MultiTarget;
	local X2AbilityTrigger_EventListener		EventListener;
	local X2Effect_ApplyPoisonToWorld PoisonEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'BrutePoison');

	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.eAbilityIconBehaviorHUD = EAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Defensive;
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_burn";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);

	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.DamageTypes.AddItem('Poison');
	Template.AddTargetEffect(DamageEffect);

	Template.AddMultiTargetEffect(class'X2StatusEffects'.static.CreatePoisonedStatusEffect());
	PoisonEffect = new class'X2Effect_ApplyPoisonToWorld';	
	Template.AddMultiTargetEffect(PoisonEffect);

	MultiTarget = new class'X2AbilityMultiTarget_Radius';
    MultiTarget.bUseWeaponRadius = true;
	MultiTarget.bExcludeSelfAsTargetIfWithinRadius = false;
	Template.AbilityMultiTargetStyle = MultiTarget;

	// This ability fires when the unit takes damage
	EventListener = new class'X2AbilityTrigger_EventListener';
	EventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventListener.ListenerData.EventID = 'UnitTakeEffectDamage';
	EventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_Self;
	EventListener.ListenerData.Filter = eFilter_Unit;
	Template.AbilityTriggers.AddItem(EventListener);

	Template.bSkipFireAction = true;
	Template.bShowActivation = true;
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;

	return Template;
}





	
	

	
